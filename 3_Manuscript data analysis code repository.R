#####################################################
#### 3. Manuscript data analysis code repository ####
#####################################################

# 1. Quantify Exonic, Intronic and Intergenic Read Proportions (Figure 1)
# 2. Plot sequencing read mapping to genomic locus (Figure 1)
# 3. Determine gene types by dominant source of read mapping (exonic, intronic, intergenic) (Figure 1)
# 4. Plot intergenic read mapping proximal to 3' end of genes (Figure 2)
# 5. Plot transcript structures (Figure 3)
# 6. Extended data figure 2: comparison of pre-mRNA mapping strategies

#################################################################################
#### 1. Quantify Exonic, Intronic and Intergenic Read Proportions (Figure 1) ####
#################################################################################

#### Input file ####
####################

# Cell Ranger (4.00 or newer) aligned sequencing data (.bam file).

#### Code ####
##############


BiocManager::install("GenomicAlignments")
library("GenomicAlignments")

bamfile = file.path("<path_to_data>/possorted_genome_bam.bam")
indexfile = file.path("<path_to_data>/possorted_genome_bam.bam")
import_data = readGAlignments(bamfile, index=indexfile, param = ScanBamParam(flag = scanBamFlag(isSecondaryAlignment = FALSE), tag = c("GN", "RE", "AN", "xf", "NH"), what = "flag")) # Imports all all aligned reads (except secondary alignments). These include all duplicate reads.
import_data = as.data.frame(import_data)
import_data = import_data[import_data$NH==1, ] # keep only uniquely mapped reads (i.e. single genomic location).
a = table(import_data$RE) # RE tag contains Cell Ranger generated read identity (E=exonic, N=intronic, I=intergenic). Note that Cell Ranger (up to 6.1.2 unless they fix it later), wrongly classifies reads antisense to exons as exonic (10x Genomics confirmed). These false exonic reads can be identified by looking up entries in AN tag (lists genes antisense to read's mapping location).
intronic_reads = a["N"] # final intronic read count

b = table(import_data$RE[is.na(import_data$AN)]) # Classification of all non-antisense reads.
preliminary_intergenic_reads = b["I"] # Intergenic reads that do not include false exonic reads.
corrected_exonic_reads = b["E"] # this is true exonic read count (RE=E and AN=NA) which excludes false exonic reads (RE=E and AN!=NA). 

false_exonic_reads = nrow(import_data[!is.na(import_data$AN),]) # Identifies number of false exonic reads (RE=E and AN!=NA).
corrected_intergenic_reads = preliminary_intergenic_reads + false_exonic_reads

corrected_exonic_reads
intronic_reads
corrected_intergenic_reads

#####################################################################
#### 2. Plot sequencing read mapping to genomic locus (Figure 1) ####
#####################################################################

BiocManager::install("Sushi")

# Generate bed file with all sequencing reads
library("GenomicAlignments")
library("GenomicRanges")
library("rtracklayer")

bamfile = file.path("<location_of_aligned_sequencing_data>/possorted_genome_bam.bam")
indexfile = file.path("<location_of_aligned_sequencing_data>/possorted_genome_bam.bam.bai")
loaded_data = readGAlignments(bamfile, index=indexfile, param = ScanBamParam(flag = scanBamFlag(isDuplicate = FALSE, isSecondaryAlignment = FALSE), tag = c("GN", "RE"), what = "flag"))
a = data.frame(loaded_data)


loaded_data = asBED(loaded_data)
export.bed(m, con = "<save_destination_folder>/reads.bed")

# Plot reads with "Sushi"
library("Sushi")

bed_input = read.table("reads.bed", sep = "\t")

chrom = "<chromosome_of_interest>"
chromstart = <start_site_chromosome_coordinate>
chromend = <end_site_chromosome_coordinate>
plotBed(beddata = bed_input,chrom = chrom, chromstart = chromstart, chromend =chromend, colorby = loaded_data$strand,colorbycol = SushiColors(2),row  = "auto", wiggle=0.001)
labelgenome(chrom, chromstart, chromend, n=2, scale="Kb")
legend("topleft",inset=0, legend=c("reverse","forward"), fill=SushiColors(2)(2), border=SushiColors(2)(2), text.font=2, cex=0.75)



##############################################################################################################
#### 3. Determine gene types by dominant source of read mapping (exonic, intronic, intergenic) (Figure 1) ####
##############################################################################################################

#### Load libraries ####
########################

library(Seurat)
library(Matrix)

#### Input data ####
####################

# Gene-cell matrix files generated by the cellranger count pipeline in regular exonic mapping mode
# Gene-cell matrix files generated by the cellranger count pipeline using a premrna reference (transcripts defined as exons, see "1_Annotation pre-processing.R" end for how to generate)
# Cell Ranger count aligned sequenging read "xxx.bam" file (preferably performed in the regular exonic mapping mode)

#### Code ####
##############

#### Load in exonically and intronically mapped read data

seq_exonic <- Read10X(data.dir = "<location of exonically mapped gene barcode matrix files>")
seq_exonic <- CreateSeuratObject(MnPO_exonic, min.features = 0, min.cells = 0, project = "Exonic")

seq_premrna <- Read10X(data.dir = "<location of pre-mRNA gene barcode matrix files>")
seq_premrna <- CreateSeuratObject(MnPO_premrna, min.features = 0, min.cells = 0, project = "premrna")

exonic_reads = GetAssayData(MnPO_exonic, slot = "counts")

exon_sums = rowSums(GetAssayData(object = seq_exonic, slot = "counts"))
premrna_sums = rowSums(GetAssayData(object = seq_premrna, slot = "counts"))

exon_sums["<gene of interest>"] # total number of exonic reads for a gene of interest 
premrna_sums["<gene of interest>"] # total number of exonic+intronic reads for a gene of interest

#### Acquire intergenic read data

## Load sequencing data from transcriptome aligned .bam file (note, needs to be aligned with Cell Ranger!).

bamfile = file.path("<file_location>/possorted_genome_bam.bam")
indexfile = file.path("<file_location>/possorted_genome_bam.bam") #Note, you don't have to specify ".bai" extension here.
seq_data = readGAlignments(bamfile, index=indexfile, param = ScanBamParam(flag = scanBamFlag(isDuplicate = FALSE, isSecondaryAlignment = FALSE), tag = c("GN", "RE", "CB", "UB", "AN"), what = "flag", tagFilter = list("RE"=c("I", "E")))) # Extract all non-duplicate intergenic and exonic sequening reads with the following bam tags: "GN" - aligned gene; "RE" - read classification into E-exonic, N-intronic, I-intergenic; "CB" - corrected cellular barcode; "UB" - corrected UMI/molecular barcode, "AN" - antisense gene.
seq_data = data.frame(seq_data)

## Keep only intergenic reads by removing all true exonic reads (i.e. remove exonic reads that lack antisense gene mapping: AN tag =NA)
intergenic_reads = seq_data$RE=="I"
false_exonic_reads = !is.na(seq_data$AN)
all_intergenic_reads = as.logical(intergenic_reads + false_exonic_reads)

seq_data = seq_data[all_intergenic_reads,] # remaining dataframe contains only intergenic reads. Note, that we are assuming that all false exonic reads are intergenic, which slightly overestimates intergenic read count. This is since some will likely also end up being intronic.

## Remove all duplicate reads and reads with corrupt barcodes (i.e. keep reads with 16 nucleotide cellular barcodes and 10 nucleotide molecular barcodes). Note that duplicate removal is required since Cell Ranger does not automatically flag duplicates for intronically and intergenically classified reads.

library(stringr)
seq_data$CB = str_sub(seq_data$CB, end=-3) # Remove last two elements of the cell barcode. This is an artifact ("-1") added by Cell Ranger software.
seq_data$barcodes = paste(seq_data$CB, seq_data$UB, sep="") # Assemble the cell barcode / molecular barcode list. Each read included in the gene_cell matrix will have a unique index comprised of the two.

a = nchar(seq_data$barcodes)==26 # logical vector for selecting reads with non-corrupt barcodes
seq_data = seq_data[a,] # exclude all reads that don't have an intact full cellular and molecular barcodes
length(unique(seq_data$barcodes)) # Determine # of unique intergenic reads
seq_data = seq_data[!duplicated(seq_data$barcodes),] # exclude all duplicated intergenic reads

## Save extracted intergenic reads as a separate file
gr_seq_data = makeGRangesFromDataFrame(seq_data) # coerce to granges object as that makes it possible to save it as a bedfile that bedtools can parse

ga_seq_data = as(gr_seq_data, "GAlignments") # Coerces GRanges object into a GAlignments object, that can be saved as a bed file. Required for bedtools to link reads to closest 3' gene end.
m = asBED(ga_seq_data)# converts GAlignments object into the bed format
export.bed(m, con = "<save_location>/intergenic_reads.bed")

## Create gene ranges file for linking reads to genes (note: partially in BASH/Terminal) 

# Purpose: Make a bed file with gene boundaries, which is required for assigning intergenic reads to a specific gene. This step is in bash with one step in R.

# Input: Genome annotation file ("xxx.gtf" file, from 10x Genomics provided reference transcriptome "gene" folder: can be downloaded at "https://support.10xgenomics.com/single-cell-gene-expression/software/downloads/latest" or Ensembl.org if wish to customize more)

# Notes:
# Part of this step should be run in linux Terminal in Bash.
# This step requires bedtools: https://bedtools.readthedocs.io/en/latest/content/installation.html. Put it in PATH after installing.

# In bash/linux terminal: Create bed file with gene boundaries from the gene annotation ("xxx.gtf") file (perform in linux Terminal in bash!)
# In bash/linux terminal, navigate to folder with the genome annotation of interest. Assuming that it is named "genes.gtf" per 10x Genomics convention.

grep -P '\tgene\t' genes.gtf > gene_ranges.gtf # extracts all "gene" entries from genome annotation and saves to a new file 

# In bash/linux terminal: Add "transcript_id """ column to the gtf file to make it compatible with bedtools format
awk '{ if ($0 ~ "transcript_id") print $0; else print $0" transcript_id \"\";"; }' gene_ranges.gtf > gene_ranges1.gtf # can discard the original, can discard
rm gene_ranges.gtf # removes intermediate file

# In bash/linux terminal: Convert reference gtf into bed with bedtools
export PATH=<path_to_bedtools_bin_folder>:$PATH  # Include bedtools location to path.
gtf2bed < gene_ranges1.gtf > gene_ranges.bed # Creates a bed file with gene boundaries

# In R: Replace final column with gene name. Make sure you navigate to same folder in R.

library(stringr)
gene_ranges = read.table("gene_ranges.bed", sep = "\t")

for (i in 1:dim(gene_ranges)[1])
{
  a = gene_ranges[i,10]
  res <- str_match(a, "gene_name\\s*(.*?)\\s*;")
  b = res[,2]
  gene_ranges[i, 10] = b
}

# In R: save outcome
write.table(gene_ranges, "gene_ranges.bed", sep="\t",row.names=FALSE, col.names=FALSE, quote = FALSE)

## Link intergenic reads to their closes 3' end of a gene

# In bash/linux terminal: Make sure bedtools is in PATH.

export PATH=<location of bedtools bin folder>:$PATH # Places bedtools in path.

sortBed -i intergenic_reads.bed > intergenic_reads1.bed # sort intergenic reads file
sortBed -i gene_ranges.bed > gene_ranges1.bed  # sort gene ranges file

bedtools closest -a intergenic_reads1.bed -b gene_ranges1.bed -s -D a -fu > results.txt # resulting file contains sequencing reads with distance data from closest 3' gene identity and end


#### Assemble summary file and acquire estimates (everything in R from here on)

master_list = data.frame(premrna_sums, exon_sums)
master_list$intron_sums = master_list$premrna_sums - master_list$exon_sums
master_list$UTR_reads = rep(0, length(dim(master_list)[1]))
master_list$exon_percent = rep(0, length(dim(master_list)[1]))
master_list$intron_percent = rep(0, length(dim(master_list)[1]))
master_list$UTR_percent = rep(0, length(dim(master_list)[1]))

# Add intergenic read data to master_list

intergenic_reads = read.table("results.txt", sep = "\t")

intergenic_reads = intergenic_reads[intergenic_reads$V23>-10000,]
intergenic_reads = intergenic_reads[intergenic_reads$V23<0,]
hist(intergenic_reads$V23)

a = table(intergenic_reads$V22)
o = order(a, decreasing = TRUE)
a[o][1:100]
length(a)
b = a[o]
length(b[b>100])

for (i in 1:length(a)){
  sel = names(a)[i]
  master_list[sel,]$UTR_reads = a[sel]
}

#### Key metrics
master_list=master_list[1:32285,]
sum(master_list$exon_sums>0) # Genes detected by exonic mapping only
sum(master_list$premrna_sums>0) # Genes detected by traditional pre-mRNA mapping
dim(master_list)[1] - sum(master_list$exon_sums==0 & master_list$UTR_reads==0)# Genes detected by exon+UTR mapping
dim(master_list)[1] - sum(master_list$exon_sums==0 & master_list$UTR_reads==0 & master_list$premrna_sums==0)# Genes detected by exon+UTR mapping # Genes detected by exon + traditional pre-mRNA + UTR mapping

sum(master_list$UTR_reads>0) # Genes with any UTR mapping

sum(master_list$exon_sums==0) # Genes with 0 reads with exonic mapping
sum(master_list$exon_sums==0 & master_list$intron_sums==0 & master_list$UTR_reads==0) # How many genes don't have any intronic/exonic/UTR reads mapping
sum(master_list$intron_sums<0) # Genes that have fewer reads with premrna mapping than exonic mapping
sum(master_list$intron_sums>0) # Genes that have more reads with premRNA than exonic mapping
sum(master_list$exon_sums==0 & master_list$intron_sums==0) # genes with no exonic nor intronic mapping (note, gene overlaps obscure)
sum(master_list$exon_sums<master_list$intron_sums) # intronically mapped reads exceeding exonically mapped reads
sum(master_list$exon_sums<master_list$UTR_reads) # 3'UTR reads exceeding exonic reads
sum(master_list$exon_sums==0 & master_list$intron_sums>0) # genes with 0 exonically mapped genes with intronic reads
sum(master_list$exon_sums==0 & master_list$UTR_reads>0) # genes with 0 exonically mapped genes with 3' UTR reads
sum(master_list$exon_sums==0 & master_list$UTR_reads>0 & master_list$intron_sums>0) # genes with no exonic mapping but have both intronic and UTR mapping
sum(master_list$exon_sums>0  & master_list$intron_sums>master_list$exon_sums)# Genes with exonic mappings, that have more intronic mappings
sum(master_list$exon_sums>0  & master_list$UTR_reads>master_list$exon_sums) # Genes with exonic mappings, that have more 3' mappings


#### Plot graph on source of sequencing reads revealing genes

# Criteria: Include only genes that have 0 or higher intronic_sums. 
# Instructions: Plot 4 bar graph, where bar 1: # of genes where more than 50% of reads map to introns, bar2: # of genes where more than 50% of reads map to introns; bar3: # of genes where more than 50% of reads map to 3' intrgenic region, bar4: mixed (i.e. the rest)
# Step 1: Eliminate genes where intron_sums for some reason are below 0 (issues with conversion to premrna mapping)
# Step 2: Calculate exonic, intronic and 3' intergenic read percentages.
# Step 3: Eliminate all genes that have fewer than 100 reads total mapping throughout its span. 
# Step 4: Calculate relevant metrics and estimate which genes are "exon mapping dominant" - i.e. more than 50% of genes map to exons, "intronic dominant", "3' intergenic dominant" - more than 50% of reads map within 10kb of the 3' end of a gene.

master_list = master_list[master_list$intron_sums>=0,]
master_list$total_reads = master_list$exon_sums + master_list$intron_sums + master_list$UTR_reads
master_list$exon_percent = master_list$exon_sums/master_list$total_reads*100
master_list$intron_percent = master_list$intron_sums/master_list$total_reads*100
master_list$UTR_percent = master_list$UTR_reads/master_list$total_reads*100
master_list = master_list[master_list$total_reads>=100,]
a = dim(master_list)[1] # Total gene list to evaluate the dominant source of read mapping for genes. 12 146 genes
e = dim(master_list[master_list$exon_percent>50,])[1]
i = dim(master_list[master_list$intron_percent>50,])[1]
u=dim(master_list[master_list$UTR_percent>50,])[1]
o = a-e-i-u
percent_exon_dominant = e*100/a
percent_intron_dominant = i*100/a
percent_UTR_dominant = u*100/a
percent_other = o*100/a

percent_exon_dominant
percent_intron_dominant
percent_UTR_dominant
percent_other

################################################################################
#### 4. Plot intergenic read mapping proximal to 3' end of genes (Figure 2) ####
################################################################################

#### Rationale ####
###################

# Intergenic reads are extracted from Cell Ranger aligned bam file. Intergenic reads can be identified by two features: their read identity tag RE = "I" (for intergenic) OR
# their RE=E (for exonic) with AN = <some gene>. The latter reads are in fact mostly intergenic reads with some also stemming from introns since Cell Ranger wrongly classifies reads mapping antisense to an exon as exonic (i.e. RE="E").
# For plotting the intergenic read distribution proximal to 3' gene ends we will use only intergenic reads as classified by Cell Ranger (RE=I) to avoid skewing data from intronic sequences.

#### Input data ####
####################

# Cell Ranger aligned seqencing data ("xxx.bam" file, regular exonic mapping)/


#### Code ####
##############

library("GenomicAlignments")
library("GenomicRanges")
library("rtracklayer")

#### Extract intergenic reads from transcriptome aligned sequencing data ("xxx.bam" file)

bamfile = file.path("<location of aligned scRNA-seq data>/possorted_genome_bam.bam")
indexfile = file.path("<location of aligned scRNA-seq data>/possorted_genome_bam.bam")
loaded_data = readGAlignments(bamfile, index=indexfile, param = ScanBamParam(flag = scanBamFlag(isDuplicate = FALSE, isSecondaryAlignment = FALSE), tag = c("GN", "RE"), what = "flag", tagFilter = list("RE"="I")))
tags1 = data.frame(loaded_data)

## Remove all exonic reads that don't have an antisense gene mapping (i.e. AN!=NA)
intergenic_reads = tags1$RE=="I"
false_exonic_reads = !is.na(tags1$AN)
all_intergenic = as.logical(intergenic_reads + false_exonic_reads)

tags1 = tags1[intergenic_reads,]


## Extract only unique intergenic reads with proper bacrodes (i.e. 16 nucleotide cellular barcodes and 10 nucleotide molecular barcodes)

library(stringr)
tags1$CB = str_sub(tags1$CB, end=-3) # Remove last two elements of the cell barcode. This is an artefact ("-1") added by the CellRanger software.
tags1$barcodes = paste(tags1$CB, tags1$UB, sep="") # Assemble the cell barcode / molecular barcode list. Each read included in the gene_cell matrix will have a unique index comprised of the two.

a = nchar(tags1$barcodes)==26
tags1 = tags1[a,] # select all reads that have an intact full cellular and molecular barcodes
length(unique(tags1$barcodes)) # Determine # of unique intergenic reads
tags1 = tags1[!duplicated(tags1a$barcodes),] # remove all duplicate reads

## Save extracted intergenic reads as a separate file
gr_tags = makeGRangesFromDataFrame(tags1) # coerce to granges object as that makes it possible to save it as a bedfile that bedtools can parse

ga_tags = as(gr_tags, "GAlignments") # Coerces GRanges object to GAlignments object, that can be saved as bed
m = asBED(ga_tags)# converts GAlignments object into the bed format
export.bed(m, con = "<destination_folder_location>/intergenic_reads.bed")


#### Create gene ranges file for linking reads to genes (note: partially in BASH/Terminal) 

## Purpose: Make a bed file with gene boundaries, which is required for assigning intergenic reads to a specific gene. This step is in bash with one step in R.

## Input: Genome annotation file ("xxx.gtf" file, from 10x Genomics provided reference transcriptome "gene" folder: can be downloaded at "https://support.10xgenomics.com/single-cell-gene-expression/software/downloads/latest" or Ensembl.org if wish to customize more)

# Notes:
# Part of this step should be run in linux Terminal in Bash.
# This step requires bedtools: https://bedtools.readthedocs.io/en/latest/content/installation.html. Put it in PATH after installing.

# In bash/linux terminal: Create bed file with gene boundaries from the gene annotation ("xxx.gtf") file (perform in linux Terminal in bash!)
# In bash/linux terminal, navigate to folder with the genome annotation of interest. Assuming that it is named "genes.gtf" per 10x Genomics convention.

grep -P '\tgene\t' genes.gtf > gene_ranges.gtf # extracts all "gene" entries from genome annotation and saves to a new file 

# In bash/linux terminal: Add "transcript_id """ column to the gtf file to make it compatible with bedtools format
awk '{ if ($0 ~ "transcript_id") print $0; else print $0" transcript_id \"\";"; }' gene_ranges.gtf > gene_ranges1.gtf # can discard the original, can discard
rm gene_ranges.gtf # removes intermediate file

# In bash/linux terminal: Convert reference gtf into bed with bedtools
export PATH=<path_to_bedtools_bin_folder>:$PATH  # Include bedtools location to path.
gtf2bed < gene_ranges1.gtf > gene_ranges.bed # Creates a bed file with gene boundaries

# In R: Replace final column with gene name. Make sure you navigate to same folder in R.

library(stringr)
gene_ranges = read.table("gene_ranges.bed", sep = "\t")

for (i in 1:dim(gene_ranges)[1])
{
  a = gene_ranges[i,10]
  res <- str_match(a, "gene_name\\s*(.*?)\\s*;")
  b = res[,2]
  gene_ranges[i, 10] = b
}

# In R: save outcome
write.table(gene_ranges, "gene_ranges.bed", sep="\t",row.names=FALSE, col.names=FALSE, quote = FALSE)


#### In bash/linux terminal: Isolate all intergenic reads within a given distance from 3' end of genes

export PATH=/opt/bedtools/bin:$PATH # Places bedtools in path.

sortBed -i intergenic_reads.bed > intergenic_reads1.bed
sortBed -i gene_ranges.bed > gene_ranges1.bed 

bedtools closest -a intergenic_reads1.bed -b gene_ranges1.bed -s -D a -fu > results.txt

## In R: extract all reads within 10kb of gene ends

intergenic_data = read.table("results.txt", sep = "\t")
max(intergenic_data$V23)
min(intergenic_data$V23)

intergenic_data = intergenic_data[intergenic_data$V23>-10000,] # removes all reads beyond 10kb of gene ends
intergenic_data = intergenic_data[intergenic_data$V23<0,]
hist(intergenic_data$V23)

ggplot(intergenic_data, aes(x=V23))+
  geom_histogram(binwidth = 25, color=F, fill="black")+
  theme_classic()+
  scale_x_continuous("Distance from gene end")+
  scale_y_continuous("Mapped reads")+
  labs(title = "Mouse intergenic read mapping near known gene ends")


##################################################
#### 5. Plot transcript structures (Figure 3) ####
##################################################

#### Load libraries
BiocManager::install("Gviz")
library("Gviz")
library("GenomicRanges")
library("rtracklayer") # For coercing data to bed format
library("IRanges")



#### Plot gene overlaps

# Input gene ranges can be taken from the original genome reference ("genes.gtf" from the "genes" folder in the transcriptomic reference from 10x.) and transferred to a new gtf file. Imporant: the new .gtf file should contain only features including CDSs, exons and UTRs but NO transcripts or genes

gtf.gr <- import(con ="<location_of_input_gtf>/<input_gtf>.gtf", format = "gtf" )

gtf.gr = as.data.frame(gtf.gr)
gtf.gr = gtf.gr[,c(1,2,3,4,5,7,10,27,12,15)]
colnames(gtf.gr) = c("chromosome", "start", "end", "width", "strand", "feature", "gene", "exon", "transcript", "symbol")

# Genomic coordinates
ref_track <- GenomeAxisTrack()

# Generate ideogram
gen = "mm10"
chr = "chr17"
itrack <- IdeogramTrack(genome = gen, chromosome = chr)

# Plot

gene_track <- GeneRegionTrack(gtf.gr, genome = gen, chromosome = chr, name = "Gene Model", transcriptAnnotation = "symbol")
plotTracks(list(itrack, ref_track, gene_track))



##############################################################################
#### 6. Extended data figure 2: comparison of pre-mRNA mapping strategies ####
##############################################################################

#### Input data ####
####################

# Here we compared three different strategies for incorporating intronic reads in the resulting gene-cell matrix (i.e. pre-mRNA reference methods)

#### Strategy 1: Traditional pre-mRNA reference with transcripts defined as exons

# Can be generated from the regular 10x genomics provided genome annotation (.gtf) file.
# Can use R for this purpose:

library("rtracklayer")

exonic_df<- import(con = '<location_of_genome_annotation>/name.gtf', format = "gtf") # Import the original exonic genome annotation file
exonic_df = as.data.frame(exonic_df)
premrna_df = exonic_df[exonic_df$type == "transcript",] # Extract all "transcript" entries in the genome annotation to a new variable
premrna_df = premrna_df$type = rep("exon", nrow(premrna_df)) # Rename all "feature" 

premrna_df = makeGRangesFromDataFrame(premrna_df, keep.extra.columns=TRUE)
rtracklayer::export(premrna_df, "premrna.gtf", format = "gtf")

# Alternatively you can also just use the linux command line:
grep -P '\ttranscript\t' genes.gtf > premRNA_genes.gtf
sed -i 's/\ttranscript\t/\texon\t/' premRNA_genes.gtf

# the resulting traditional pre-mRNA genome annotation needs to be converted into a Cell Ranger reference transcriptome (again in linux command line)

cellranger mkref --genome=traditional_premRNA_reference --fasta=genome.fa --genes=premRNA_genes.gtf # note that you can get genome.fa from the "genome" folder of the basic transcriptomic reference from 10x Genomics

# the resulting Cell Ranger pre-mRNA reference transcriptome is used to map sequencing data (again in linux command line)

cellranger count --id <output_folder_name> --transcriptome traditional_premRNA_reference --fastqs <location_of_fastq_files> --sample <sample_id>

#### Strategy 2: STARsolo --Genefull mode for capturing intronic reads

# Requires STAR 2.7.9a in path
# Generated from scRNA-seq sequencing data (fastq files) and run in linux termnal:

STAR --genomeDir <location_of_regular_10x_genomics/ensembl_reference> --readFilesIn <location_of_fastq_files> --clipAdapterType CellRanger4 --outFilterScoreMin 30 --soloCBmatchWLtype 1MM_multi_Nbase_pseudocounts --soloUMIfiltering MultiGeneUMI_CR --soloUMIdedup 1MM_CR  --outSAMtype BAM SortedByCoordinate --readFilesCommand zcat --soloType CB_UMI_Simple --bamRemoveDuplicatesType UniqueIdenticalNotMulti --outSAMattributes NH HI AS nM GX GN sM sQ --soloFeatures GeneFull --soloCBwhitelist <location_of_whitelist>/737K-august-2016.txt
samtools index Aligned.sortedByCoord.out.bam


#### Strategy 3: Cell Ranger --include-introns for capturing intronic reads

# Requires Cell Ranger 4.00 or older
# Generated from scRNA-seq sequencing data (fastq files) and run in linux termnal:
cellranger count --id <output_folder_name> --transcriptome <location_of_regular_10x_genomics/ensembl_reference> --fastqs <location_of_fastq_files> --include-introns --sample <sample_id>


#### Code ####
##############

#### Here we compare the overlap between genes and specific reads that get registered by the three different methods for pre-mRNA references.

#### Establish reads and gene number from gene-cell matrix (note - from raw data!)

library(Seurat)
expression_data <- Read10X(data.dir = "<location_of_raw_gene_cell_matrix_files") # use gene_cell matrices from different pre-mRNA capturing strategies
expression_data <- CreateSeuratObject(expression_data, min.features = 0, min.cells = 0, project = "Exonic")
expression_sums = rowSums(GetAssayData(object = exonic, slot = "counts"))
sum(expression_sums) # total reads in gene-cell matrix
sum(expression_sums>1) # total number of detected genes

#### Traditional pre-mRNA dataset (transcripts as exons, Cell Ranger)

bamfile = file.path("<location_of_bam_file>/possorted_genome_bam.bam")
indexfile = file.path("<location_of_bam_file>/possorted_genome_bam.bam")
loaded_data1 = readGAlignments(bamfile, index=indexfile, param = ScanBamParam(flag = scanBamFlag(isDuplicate = FALSE, isSecondaryAlignment = FALSE), tag = c("GN", "RE", "AN", "xf", "NH", "CB", "UB"), what = "flag"))

tags1 = as.data.frame(loaded_data1)
rm(loaded_data1)
dim(tags1)

tags1a = tags1[tags1$xf==25,] # Cell Ranger tags all genes that get incorporated to gene-cell matrix with xf=25
dim(tags1a)

rm(tags1)

library(stringr)
tags1a$CB = str_sub(tags1a$CB, end=-3) # Remove last two elements of the cell barcode. This is an artefact ("-1") added by the CellRanger software.
barcodes1 = paste(tags1a$CB, tags1a$UB, sep="") # Assemble the cell barcode / molecular barcode list. Each read included in the gene_cell matrix will have a unique index comprised of the two. Note that these are all the reads that get incorporated to gene-cell matrix with the traditional pre-mRNA method.
rm(tags1a)

#### STARSOLO dataset

bamfile = file.path("<location_of_bam_file>/Aligned.sortedByCoord.out.bam")
indexfile = file.path("<location_of_bam_file>/Aligned.sortedByCoord.out.bam")
loaded_data2 = readGAlignments(bamfile, index=indexfile, param = ScanBamParam(flag = scanBamFlag(isDuplicate = FALSE, isSecondaryAlignment = FALSE), tag = c("NH", "HI", "AS", "nM", "GX", "GN", "sM", "sQ", "CB", "UB"), what = "flag"))

tags2 = as.data.frame(loaded_data2)
rm(loaded_data2)
dim(tags2)

tags2a = tags2[!(is.na(tags2$GX)),] # select reads that map to a gene
a = nchar(tags2a$CB)==16
tags2b = tags2a[a,] # select reads that map to a gene
b = nchar(tags2b$UB)==10
tags2b = tags2b[b,] # select reads that map to a gene
dim(tags2b)

rm(tags2a)
rm(a)
rm(b)

barcodes2 = paste(tags2b$CB, tags2b$UB, sep="") # assemble the read barcode (comprised of corrected cellular and molecular barcodes)
barcodes2 = unique(barcodes2)
rm(tags2b)

length(unique(barcodes2))

tags2b$barcodes = barcodes2
tags2b = tags2b[!duplicated(tags2b$barcodes),]
dim(tags2b)
length(unique(barcodes2))

sum(!duplicated(tags2a$barcodes))
sum(!duplicated(tags2a$barcodes))


barcodes2 = unique(barcodes2)
length(barcodes2)



#### Cell Ranger --include-introns mode

bamfile = file.path("<location_of_bam_file>/possorted_genome_bam.bam")
indexfile = file.path("<location_of_bam_file>/possorted_genome_bam.bam")
loaded_data1 = readGAlignments(bamfile, index=indexfile, param = ScanBamParam(flag = scanBamFlag(isDuplicate = FALSE, isSecondaryAlignment = FALSE), tag = c("GN", "RE", "AN", "xf", "NH", "CB", "UB"), what = "flag"))

tags3 = as.data.frame(loaded_data1)
rm(loaded_data1)
dim(tags3)

tags3a = tags3[tags3$xf==25,]
dim(tags3a)

rm(tags3)

library(stringr)
tags3a$CB = str_sub(tags3a$CB, end=-3) # Remove last two elements of the cell barcode. This is an artefact ("-1") added by the CellRanger software.
barcodes3 = paste(tags3a$CB, tags3a$UB, sep="") # Assemble the cell barcode / molecular barcode list. Each read included in the gene_cell matrix will have a unique index comprised of the two.
barcodes3 = unique(barcodes3)
rm(tags3a)


####

length(intersect(barcodes1, barcodes3)) # overlap between Cell Ranger traditional pre-mRNA and Cell Ranger --include-introns mode reads
length(intersect(barcodes1, barcodes2)) # overlap between Cell Ranger traditional pre-mRNA and STARsolo --Fullgene mode
length(intersect(barcodes2, barcodes3)) # overlap between  STARsolo --Fullgene mode and Cell Ranger --include-introns mode reads

a = intersect(barcodes1, barcodes2)
b = intersect(a, barcodes3)
length(b) # number of reads that are detected by all three methods
